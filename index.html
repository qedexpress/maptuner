<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OSM åœ°å›¾æ ‡æ³¨å·¥å…· (JSONç”Ÿæˆå™¨)</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin=""/>
    
    <style>
        body { margin: 0; padding: 0; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; display: flex; height: 100vh; overflow: hidden; }
        
        /* ä¾§è¾¹æ æ ·å¼ */
        #sidebar {
            width: 350px;
            background-color: #f8f9fa;
            border-right: 1px solid #ddd;
            display: flex;
            flex-direction: column;
            padding: 20px;
            box-shadow: 2px 0 5px rgba(0,0,0,0.1);
            z-index: 1000;
            overflow-y: auto;
        }

        /* åœ°å›¾å®¹å™¨æ ·å¼ */
        #map { flex-grow: 1; height: 100%; cursor: crosshair; }

        h2 { margin-top: 0; color: #333; }
        h3 { border-bottom: 2px solid #007bff; padding-bottom: 5px; margin-bottom: 15px; color: #555; }

        /* æ§ä»¶æ ·å¼ */
        .control-group { margin-bottom: 20px; background: white; padding: 15px; border-radius: 8px; box-shadow: 0 1px 3px rgba(0,0,0,0.1); }
        .btn {
            display: block; width: 100%; padding: 10px; margin-bottom: 10px; border: none; border-radius: 4px; 
            cursor: pointer; font-size: 14px; transition: background 0.2s; color: white; text-align: center;
        }
        .btn-primary { background-color: #007bff; }
        .btn-success { background-color: #28a745; }
        .btn-danger { background-color: #dc3545; }
        .btn:hover { opacity: 0.9; }
        
        .mode-selector { display: flex; gap: 5px; margin-bottom: 10px; }
        .mode-btn { flex: 1; padding: 8px; background: #e9ecef; border: 1px solid #ced4da; cursor: pointer; color: #495057; }
        .mode-btn.active { background: #007bff; color: white; border-color: #007bff; }

        /* è¡¨å•æ ·å¼ */
        .form-group { margin-bottom: 10px; }
        .form-group label { display: block; font-size: 12px; color: #666; margin-bottom: 4px; }
        .form-group input { width: 100%; padding: 6px; box-sizing: border-box; border: 1px solid #ccc; border-radius: 4px; }
        .readonly-input { background-color: #e9ecef; color: #6c757d; }

        #output-area { margin-top: auto; }
        
        /* é€‰ä¸­çŠ¶æ€çš„ç‚¹æ ·å¼ */
        .selected-marker-icon { filter: hue-rotate(150deg); } 
    </style>
</head>
<body>

    <div id="sidebar">
        <h2>ğŸ—ºï¸ åœ°å›¾æ ‡æ³¨å·¥å…·</h2>
        
        <div class="control-group">
            <label><strong>å½“å‰æ¨¡å¼:</strong></label>
            <div class="mode-selector">
                <button class="mode-btn active" onclick="setMode('view')">æµè§ˆ/ç¼–è¾‘</button>
                <button class="mode-btn" onclick="setMode('point')">æ·»åŠ ç‚¹</button>
                <button class="mode-btn" onclick="setMode('line')">è¿çº¿</button>
            </div>
            <div id="instruction" style="font-size: 12px; color: #666; margin-top:5px;">ç‚¹å‡»åœ°å›¾ä¸Šçš„ç‚¹æˆ–çº¿è¿›è¡Œç¼–è¾‘ã€‚</div>
        </div>

        <div class="control-group">
            <label><strong>æ‹–åŠ¨æ§åˆ¶:</strong></label>
            <button id="drag-lock-btn" class="btn btn-primary" onclick="toggleDragLock()">ğŸ”“ å…è®¸æ‹–åŠ¨</button>
        </div>

        <div id="properties-panel" class="control-group" style="display:none;">
            <h3 id="prop-title">å±æ€§ç¼–è¾‘</h3>
            <div id="prop-form"></div>
            <button class="btn btn-primary" onclick="saveProperties()">ä¿å­˜ä¿®æ”¹</button>
            <button class="btn btn-danger" onclick="deleteCurrentEntity()">åˆ é™¤æ­¤é¡¹</button>
        </div>

        <div id="output-area">
            <button class="btn btn-primary" onclick="importJSON()">å¯¼å…¥ JSON æ•°æ®</button>
            <button class="btn btn-success" onclick="exportJSON()">ä¸‹è½½ JSON æ•°æ®</button>
            <input type="file" id="json-file-input" accept=".json" style="display:none;" onchange="handleFileSelect(event)">
        </div>
    </div>

    <div id="map"></div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>

    <script>
        // --- æ•°æ®å­˜å‚¨ ---
        const data = {
            nodes: [], // { uuid, name, pos: [lat, lng] }
            edges: []  // { uuid, start, end, distance, walk_punish, bike_punish, car_punish }
        };

        // --- å…¨å±€çŠ¶æ€ ---
        let map;
        let currentMode = 'view'; // view, point, line
        let selectedNodeUuid = null; // ç”¨äºè¿çº¿æ—¶çš„ç¬¬ä¸€ä¸ªç‚¹
        let editingEntity = null; // å½“å‰æ­£åœ¨ç¼–è¾‘çš„å¯¹è±¡ {type: 'node'|'edge', uuid: ''}
        let dragLocked = false; // æ‹–åŠ¨é”å®šçŠ¶æ€

        // Leaflet å›¾å±‚å­˜å‚¨ï¼Œç”¨äºäº¤äº’
        const markersMap = {}; // uuid -> leaflet marker
        const polylinesMap = {}; // uuid -> leaflet polyline

        // --- åˆå§‹åŒ–åœ°å›¾ ---
        function initMap() {
            // é»˜è®¤å®šä½åˆ°æŒ‡å®šåæ ‡
            map = L.map('map').setView([36.070165121277796, 120.41910235636723], 13);

            L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', {
                maxZoom: 19,
                attribution: '&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a>'
            }).addTo(map);

            // åœ°å›¾ç‚¹å‡»äº‹ä»¶ï¼ˆç”¨äºæ·»åŠ ç‚¹ï¼‰
            map.on('click', function(e) {
                if (currentMode === 'point') {
                    addNode(e.latlng);
                } else {
                    deselectAll();
                }
            });
        }

        // --- æ ¸å¿ƒé€»è¾‘ï¼šæ·»åŠ èŠ‚ç‚¹ ---
        function addNode(latlng) {
            const uuid = generateUUID();
            const newNode = {
                uuid: uuid,
                name: "New Point",
                pos: [latlng.lat, latlng.lng]
            };
            
            data.nodes.push(newNode);
            renderNode(newNode);
            console.log("Added Node:", newNode);
        }

        // --- æ¸²æŸ“èŠ‚ç‚¹ ---
        function renderNode(nodeData) {
            const marker = L.marker(nodeData.pos, {draggable: !dragLocked}).addTo(map);
            marker.nodeUuid = nodeData.uuid; // ç»‘å®š ID åˆ°å¯¹è±¡

            // ç‚¹å‡» Marker äº‹ä»¶
            marker.on('click', (e) => {
                L.DomEvent.stopPropagation(e); // é˜²æ­¢è§¦å‘åœ°å›¾ç‚¹å‡»
                handleNodeClick(nodeData.uuid);
            });

            // æ‹–æ‹½ Marker æ›´æ–°åæ ‡
            marker.on('dragend', (e) => {
                const newPos = e.target.getLatLng();
                const node = data.nodes.find(n => n.uuid === nodeData.uuid);
                if(node) {
                    node.pos = [newPos.lat, newPos.lng];
                    updateConnectedEdges(nodeData.uuid); // æ›´æ–°è¿æ¥çš„çº¿
                    if (editingEntity && editingEntity.uuid === nodeData.uuid) {
                        loadProperties('node', nodeData.uuid); // åˆ·æ–°é¢æ¿åæ ‡æ˜¾ç¤º
                    }
                }
            });

            markersMap[nodeData.uuid] = marker;
        }

        // --- æ ¸å¿ƒé€»è¾‘ï¼šèŠ‚ç‚¹ç‚¹å‡»å¤„ç† (è¿çº¿æˆ–ç¼–è¾‘) ---
        function handleNodeClick(uuid) {
            if (currentMode === 'line') {
                // è¿çº¿é€»è¾‘
                if (selectedNodeUuid === null) {
                    // é€‰ä¸­ç¬¬ä¸€ä¸ªç‚¹
                    selectedNodeUuid = uuid;
                    highlightMarker(uuid, true);
                    showToast("è¯·ç‚¹å‡»ç¬¬äºŒä¸ªç‚¹ä»¥è¿æ¥");
                } else if (selectedNodeUuid === uuid) {
                    // å–æ¶ˆé€‰ä¸­
                    highlightMarker(uuid, false);
                    selectedNodeUuid = null;
                } else {
                    // é€‰ä¸­ç¬¬äºŒä¸ªç‚¹ -> åˆ›å»ºè¿çº¿
                    addEdge(selectedNodeUuid, uuid);
                    highlightMarker(selectedNodeUuid, false);
                    selectedNodeUuid = null;
                }
            } else {
                // ç¼–è¾‘æ¨¡å¼
                deselectAll();
                loadProperties('node', uuid);
            }
        }

        // --- æ ¸å¿ƒé€»è¾‘ï¼šæ·»åŠ è¿çº¿ ---
        function addEdge(startUuid, endUuid) {
            // æ£€æŸ¥æ˜¯å¦é‡å¤
            const exists = data.edges.some(e => 
                (e.start === startUuid && e.end === endUuid) || 
                (e.start === endUuid && e.end === startUuid)
            );
            if (exists) {
                alert("è¿™ä¸¤ç‚¹ä¹‹é—´å·²ç»å­˜åœ¨è¿çº¿ï¼");
                return;
            }

            const startNode = data.nodes.find(n => n.uuid === startUuid);
            const endNode = data.nodes.find(n => n.uuid === endUuid);

            // è®¡ç®—è·ç¦» (ç±³)
            const dist = map.distance(startNode.pos, endNode.pos);

            const uuid = generateUUID();
            const newEdge = {
                uuid: uuid,
                start: startUuid,
                end: endUuid,
                distance: parseFloat(dist.toFixed(2)),
                walk_punish: 0,
                bike_punish: 0,
                car_punish: 0
            };

            data.edges.push(newEdge);
            renderEdge(newEdge);
            console.log("Added Edge:", newEdge);
        }

        // --- æ¸²æŸ“è¿çº¿ ---
        function renderEdge(edgeData) {
            const startNode = data.nodes.find(n => n.uuid === edgeData.start);
            const endNode = data.nodes.find(n => n.uuid === edgeData.end);

            if(!startNode || !endNode) return;

            const latlngs = [startNode.pos, endNode.pos];
            const polyline = L.polyline(latlngs, {color: 'blue', weight: 5, opacity: 0.6}).addTo(map);
            polyline.edgeUuid = edgeData.uuid;

            // çº¿æ®µç‚¹å‡»äº‹ä»¶
            polyline.on('click', (e) => {
                L.DomEvent.stopPropagation(e);
                if (currentMode === 'view') {
                    deselectAll();
                    // é«˜äº®çº¿æ®µ
                    polyline.setStyle({color: 'red'});
                    loadProperties('edge', edgeData.uuid);
                }
            });

            polylinesMap[edgeData.uuid] = polyline;
        }

        // --- æ‹–æ‹½ç‚¹æ—¶æ›´æ–°è¿çº¿è§†è§‰ ---
        function updateConnectedEdges(nodeUuid) {
            data.edges.forEach(edge => {
                if (edge.start === nodeUuid || edge.end === nodeUuid) {
                    const polyline = polylinesMap[edge.uuid];
                    const n1 = data.nodes.find(n => n.uuid === edge.start);
                    const n2 = data.nodes.find(n => n.uuid === edge.end);
                    if (polyline && n1 && n2) {
                        polyline.setLatLngs([n1.pos, n2.pos]);
                        // è‡ªåŠ¨æ›´æ–°è·ç¦»
                        edge.distance = parseFloat(map.distance(n1.pos, n2.pos).toFixed(2));
                        // å¦‚æœå½“å‰æ­£åœ¨ç¼–è¾‘è¿™æ¡çº¿ï¼Œåˆ·æ–°è·ç¦»æ˜¾ç¤º
                        if (editingEntity && editingEntity.uuid === edge.uuid) {
                            document.getElementById('inp-distance').value = edge.distance;
                        }
                    }
                }
            });
        }

        // --- å±æ€§é¢æ¿é€»è¾‘ ---
        function loadProperties(type, uuid) {
            const panel = document.getElementById('properties-panel');
            const form = document.getElementById('prop-form');
            const title = document.getElementById('prop-title');
            
            panel.style.display = 'block';
            form.innerHTML = '';
            editingEntity = { type, uuid };

            if (type === 'node') {
                const node = data.nodes.find(n => n.uuid === uuid);
                title.innerText = "ç¼–è¾‘ç‚¹å±æ€§";
                form.innerHTML += createInput('UUID', 'inp-uuid', node.uuid, true);
                form.innerHTML += createInput('åç§° (Name)', 'inp-name', node.name);
                form.innerHTML += createInput('åæ ‡ (Pos)', 'inp-pos', node.pos.join(', '), true);
            } else {
                const edge = data.edges.find(e => e.uuid === uuid);
                title.innerText = "ç¼–è¾‘çº¿å±æ€§";
                form.innerHTML += createInput('UUID', 'inp-uuid', edge.uuid, true);
                form.innerHTML += createInput('è·ç¦» (Distance)', 'inp-distance', edge.distance);
                form.innerHTML += createInput('Walk Punish', 'inp-walk', edge.walk_punish, false, 'number');
                form.innerHTML += createInput('Bike Punish', 'inp-bike', edge.bike_punish, false, 'number');
                form.innerHTML += createInput('Car Punish', 'inp-car', edge.car_punish, false, 'number');
            }
        }

        function createInput(label, id, value, readonly = false, type = 'text') {
            return `
                <div class="form-group">
                    <label>${label}</label>
                    <input type="${type}" id="${id}" value="${value}" ${readonly ? 'readonly class="readonly-input"' : ''}>
                </div>
            `;
        }

        function saveProperties() {
            if (!editingEntity) return;

            if (editingEntity.type === 'node') {
                const node = data.nodes.find(n => n.uuid === editingEntity.uuid);
                node.name = document.getElementById('inp-name').value;
                // æ›´æ–° Marker Popup æˆ– Tooltip (å¯é€‰)
                markersMap[node.uuid].bindPopup(node.name).openPopup();
            } else {
                const edge = data.edges.find(e => e.uuid === editingEntity.uuid);
                edge.distance = parseFloat(document.getElementById('inp-distance').value);
                edge.walk_punish = parseFloat(document.getElementById('inp-walk').value);
                edge.bike_punish = parseFloat(document.getElementById('inp-bike').value);
                edge.car_punish = parseFloat(document.getElementById('inp-car').value);
            }
            showToast("å±æ€§å·²ä¿å­˜");
        }

        function deleteCurrentEntity() {
            if (!editingEntity) return;
            if (!confirm("ç¡®å®šè¦åˆ é™¤å—ï¼Ÿ")) return;

            if (editingEntity.type === 'node') {
                // åˆ é™¤ç‚¹åŠç›¸å…³è¿çº¿
                const uuid = editingEntity.uuid;
                
                // 1. åˆ é™¤ç›¸å…³è¿çº¿æ•°æ®å’Œè§†å›¾
                const relatedEdges = data.edges.filter(e => e.start === uuid || e.end === uuid);
                relatedEdges.forEach(e => {
                    map.removeLayer(polylinesMap[e.uuid]);
                    delete polylinesMap[e.uuid];
                });
                data.edges = data.edges.filter(e => e.start !== uuid && e.end !== uuid);

                // 2. åˆ é™¤ç‚¹è§†å›¾
                map.removeLayer(markersMap[uuid]);
                delete markersMap[uuid];

                // 3. åˆ é™¤ç‚¹æ•°æ®
                data.nodes = data.nodes.filter(n => n.uuid !== uuid);

            } else {
                // ä»…åˆ é™¤è¿çº¿
                const uuid = editingEntity.uuid;
                map.removeLayer(polylinesMap[uuid]);
                delete polylinesMap[uuid];
                data.edges = data.edges.filter(e => e.uuid !== uuid);
            }

            deselectAll();
            document.getElementById('properties-panel').style.display = 'none';
        }

        // --- è¾…åŠ©åŠŸèƒ½ ---
        function setMode(mode) {
            currentMode = mode;
            document.querySelectorAll('.mode-btn').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active'); // ç®€å•çš„äº‹ä»¶ç›®æ ‡å¤„ç†ï¼Œå®é™…é¡¹ç›®ä¸­æœ€å¥½ç”¨ID
            
            // é‡ç½®çŠ¶æ€
            selectedNodeUuid = null;
            deselectAll();

            const instruction = document.getElementById('instruction');
            if(mode === 'view') instruction.innerText = "ç‚¹å‡»åœ°å›¾ä¸Šçš„ç‚¹æˆ–çº¿è¿›è¡Œç¼–è¾‘/æ‹–æ‹½ã€‚";
            if(mode === 'point') instruction.innerText = "ç‚¹å‡»åœ°å›¾ä»»æ„ç©ºç™½å¤„æ·»åŠ æ–°çš„ç‚¹ã€‚";
            if(mode === 'line') instruction.innerText = "ä¾æ¬¡ç‚¹å‡»ä¸¤ä¸ªç‚¹ä»¥å»ºç«‹è¿æ¥ã€‚";
        }

        function deselectAll() {
            document.getElementById('properties-panel').style.display = 'none';
            editingEntity = null;
            // é‡ç½®æ‰€æœ‰çº¿çš„é¢œè‰²
            Object.values(polylinesMap).forEach(poly => poly.setStyle({color: 'blue'}));
            // é‡ç½®æ‰€æœ‰ç‚¹çš„é¢œè‰² (è¿™é‡Œä¸»è¦æŒ‡å–æ¶ˆé«˜äº®)
            Object.keys(markersMap).forEach(k => highlightMarker(k, false));
        }

        function highlightMarker(uuid, active) {
            const marker = markersMap[uuid];
            if (!marker) return;
            const icon = marker.getElement();
            if (icon) {
                if (active) icon.classList.add('selected-marker-icon');
                else icon.classList.remove('selected-marker-icon');
            }
        }

        function generateUUID() {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
        }

        function exportJSON() {
            const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(data, null, 2));
            const downloadAnchorNode = document.createElement('a');
            downloadAnchorNode.setAttribute("href", dataStr);
            downloadAnchorNode.setAttribute("download", "map_data.json");
            document.body.appendChild(downloadAnchorNode);
            downloadAnchorNode.click();
            downloadAnchorNode.remove();
        }

        function importJSON() {
            // è§¦å‘éšè—çš„æ–‡ä»¶é€‰æ‹©æ¡†
            document.getElementById('json-file-input').click();
        }

        function handleFileSelect(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const importedData = JSON.parse(e.target.result);

                    // éªŒè¯æ•°æ®æ ¼å¼
                    if (!importedData.nodes || !importedData.edges) {
                        alert("JSON æ ¼å¼ä¸æ­£ç¡®ï¼éœ€è¦åŒ…å« nodes å’Œ edges å­—æ®µã€‚");
                        return;
                    }

                    // æ¸…é™¤å½“å‰æ‰€æœ‰åœ°å›¾å…ƒç´ 
                    clearAllMapData();

                    // å¯¼å…¥èŠ‚ç‚¹æ•°æ®
                    data.nodes = importedData.nodes;
                    data.edges = importedData.edges;

                    // å…ˆæ¸²æŸ“æ‰€æœ‰èŠ‚ç‚¹
                    data.nodes.forEach(node => {
                        renderNode(node);
                    });

                    // å†æ¸²æŸ“æ‰€æœ‰è¿çº¿
                    data.edges.forEach(edge => {
                        renderEdge(edge);
                    });

                    showToast("å¯¼å…¥æˆåŠŸï¼");

                    // è‡ªåŠ¨ç¼©æ”¾åˆ°æ‰€æœ‰ç‚¹
                    if (data.nodes.length > 0) {
                        const bounds = L.latLngBounds(data.nodes.map(n => n.pos));
                        map.fitBounds(bounds, { padding: [50, 50] });
                    }

                } catch (error) {
                    alert("å¯¼å…¥å¤±è´¥ï¼š" + error.message);
                }
            };
            reader.readAsText(file);

            // é‡ç½®æ–‡ä»¶è¾“å…¥ï¼Œå…è®¸é‡å¤å¯¼å…¥åŒä¸€æ–‡ä»¶
            event.target.value = '';
        }

        function clearAllMapData() {
            // æ¸…é™¤æ‰€æœ‰ marker
            Object.values(markersMap).forEach(marker => {
                map.removeLayer(marker);
            });
            Object.keys(markersMap).forEach(key => delete markersMap[key]);

            // æ¸…é™¤æ‰€æœ‰ polyline
            Object.values(polylinesMap).forEach(polyline => {
                map.removeLayer(polyline);
            });
            Object.keys(polylinesMap).forEach(key => delete polylinesMap[key]);

            // æ¸…é™¤æ•°æ®
            data.nodes = [];
            data.edges = [];

            // éšè—å±æ€§é¢æ¿
            deselectAll();
        }

        function toggleDragLock() {
            dragLocked = !dragLocked;
            const btn = document.getElementById('drag-lock-btn');

            if (dragLocked) {
                btn.innerText = 'ğŸ”’ å·²é”å®šæ‹–åŠ¨';
                btn.classList.remove('btn-primary');
                btn.classList.add('btn-danger');
            } else {
                btn.innerText = 'ğŸ”“ å…è®¸æ‹–åŠ¨';
                btn.classList.remove('btn-danger');
                btn.classList.add('btn-primary');
            }

            // æ›´æ–°æ‰€æœ‰ç°æœ‰ marker çš„æ‹–åŠ¨çŠ¶æ€
            Object.values(markersMap).forEach(marker => {
                if (dragLocked) {
                    marker.dragging.disable();
                } else {
                    marker.dragging.enable();
                }
            });

            showToast(dragLocked ? "å·²é”å®šæ‰€æœ‰ç‚¹çš„æ‹–åŠ¨" : "å·²è§£é”æ‰€æœ‰ç‚¹çš„æ‹–åŠ¨");
        }

        function showToast(msg) {
            // ç®€å•çš„æç¤ºï¼Œå®é™…å¯ä»¥ç”¨æ›´å¥½çœ‹çš„UI
            const d = document.createElement('div');
            d.style.cssText = "position:fixed; bottom:20px; right:20px; background:rgba(0,0,0,0.7); color:white; padding:10px 20px; border-radius:5px; z-index:9999;";
            d.innerText = msg;
            document.body.appendChild(d);
            setTimeout(() => d.remove(), 2000);
        }

        // å¯åŠ¨
        initMap();

    </script>
</body>
</html>