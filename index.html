<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OSM åœ°å›¾æ ‡æ³¨å·¥å…· (JSONç”Ÿæˆå™¨)</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin=""/>
    <link rel="stylesheet" href="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.css" crossorigin=""/>

    <style>
        body { margin: 0; padding: 0; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; display: flex; height: 100vh; overflow: hidden; }
        
        /* ä¾§è¾¹æ æ ·å¼ */
        #sidebar {
            width: 350px;
            background-color: #f8f9fa;
            border-right: 1px solid #ddd;
            display: flex;
            flex-direction: column;
            padding: 20px;
            box-shadow: 2px 0 5px rgba(0,0,0,0.1);
            z-index: 1000;
            overflow-y: auto;
        }

        /* åœ°å›¾å®¹å™¨æ ·å¼ */
        #map { flex-grow: 1; height: 100%; cursor: crosshair; }

        h2 { margin-top: 0; color: #333; }
        h3 { border-bottom: 2px solid #007bff; padding-bottom: 5px; margin-bottom: 15px; color: #555; }

        /* æ§ä»¶æ ·å¼ */
        .control-group { margin-bottom: 20px; background: white; padding: 15px; border-radius: 8px; box-shadow: 0 1px 3px rgba(0,0,0,0.1); }
        .btn {
            display: block; width: 100%; padding: 10px; margin-bottom: 10px; border: none; border-radius: 4px; 
            cursor: pointer; font-size: 14px; transition: background 0.2s; color: white; text-align: center;
        }
        .btn-primary { background-color: #007bff; }
        .btn-success { background-color: #28a745; }
        .btn-danger { background-color: #dc3545; }
        .btn-secondary { background-color: #6c757d; }
        .btn:hover { opacity: 0.9; }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; }
        
        .mode-selector { display: flex; gap: 5px; margin-bottom: 10px; }
        .mode-btn { flex: 1; padding: 8px; background: #e9ecef; border: 1px solid #ced4da; cursor: pointer; color: #495057; }
        .mode-btn.active { background: #007bff; color: white; border-color: #007bff; }

        /* è¡¨å•æ ·å¼ */
        .form-group { margin-bottom: 10px; }
        .form-group label { display: block; font-size: 12px; color: #666; margin-bottom: 4px; }
        .form-group input { width: 100%; padding: 6px; box-sizing: border-box; border: 1px solid #ccc; border-radius: 4px; }
        .readonly-input { background-color: #e9ecef; color: #6c757d; }

        #output-area { margin-top: auto; }
        
        /* é€‰ä¸­çŠ¶æ€çš„ç‚¹æ ·å¼ */
        .selected-marker-icon { filter: hue-rotate(150deg); } 
    </style>
</head>
<body>

    <div id="sidebar">
        <h2>ğŸ—ºï¸ åœ°å›¾æ ‡æ³¨å·¥å…·</h2>
        
        <div class="control-group">
            <label><strong>å½“å‰æ¨¡å¼:</strong></label>
            <div class="mode-selector">
                <button class="mode-btn active" onclick="setMode('view')">æµè§ˆ/ç¼–è¾‘</button>
                <button class="mode-btn" onclick="setMode('point')">æ·»åŠ ç‚¹</button>
                <button class="mode-btn" onclick="setMode('line')">è¿çº¿</button>
            </div>
            <div id="instruction" style="font-size: 12px; color: #666; margin-top:5px;">ç‚¹å‡»åœ°å›¾ä¸Šçš„ç‚¹æˆ–çº¿è¿›è¡Œç¼–è¾‘ã€‚</div>
        </div>

        <div class="control-group">
            <label><strong>æ“ä½œæ§åˆ¶:</strong></label>
            <div style="display: flex; gap: 5px;">
                <button id="drag-lock-btn" class="btn btn-primary" onclick="toggleDragLock()" style="flex: 1; margin: 0;">ğŸ”“ å…è®¸æ‹–åŠ¨</button>
                <button id="undo-btn" class="btn btn-primary" onclick="undo()" style="flex: 1; margin: 0;" disabled>â†¶ æ’¤é”€</button>
                <button id="redo-btn" class="btn btn-primary" onclick="redo()" style="flex: 1; margin: 0;" disabled>â†· é‡åš</button>
            </div>
            <div style="font-size: 11px; color: #999; margin-top: 3px;">å¿«æ·é”®: Ctrl+Z æ’¤é”€ | Ctrl+Y é‡åš</div>
        </div>

        <div class="control-group">
            <label><strong>è‡ªåŠ¨æ‰“ç‚¹:</strong></label>
            <button class="btn btn-success" onclick="startAutoMarking()">ğŸ“ æ¡†é€‰åŒºåŸŸè‡ªåŠ¨æ‰“ç‚¹</button>
            <div id="auto-mark-status" style="font-size: 12px; color: #666; margin-top:5px;"></div>
        </div>

        <div id="properties-panel" class="control-group" style="display:none;">
            <h3 id="prop-title">å±æ€§ç¼–è¾‘</h3>
            <div id="prop-form"></div>
            <button class="btn btn-primary" onclick="saveProperties()">ä¿å­˜ä¿®æ”¹</button>
            <button class="btn btn-danger" onclick="deleteCurrentEntity()">åˆ é™¤æ­¤é¡¹</button>
        </div>

        <div id="output-area">
            <button class="btn btn-primary" onclick="importJSON()">å¯¼å…¥ JSON æ•°æ®</button>
            <button class="btn btn-success" onclick="exportJSON()">ä¸‹è½½ JSON æ•°æ®</button>
            <input type="file" id="json-file-input" accept=".json" style="display:none;" onchange="handleFileSelect(event)">
        </div>
    </div>

    <div id="map"></div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
    <script src="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.js" crossorigin=""></script>

    <script>
        // --- æ•°æ®å­˜å‚¨ ---
        const data = {
            nodes: [], // { uuid, name, pos: [lat, lng] }
            edges: []  // { uuid, start, end, distance, walk_punish, bike_punish, car_punish }
        };

        // --- å…¨å±€çŠ¶æ€ ---
        let map;
        let currentMode = 'view'; // view, point, line
        let selectedNodeUuid = null; // ç”¨äºè¿çº¿æ—¶çš„ç¬¬ä¸€ä¸ªç‚¹
        let editingEntity = null; // å½“å‰æ­£åœ¨ç¼–è¾‘çš„å¯¹è±¡ {type: 'node'|'edge', uuid: ''}
        let dragLocked = false; // æ‹–åŠ¨é”å®šçŠ¶æ€
        let rectangleSelector = null; // ç”¨äºæ¡†é€‰çš„çŸ©å½¢
        let isAutoMarkingMode = false; // æ˜¯å¦å¤„äºè‡ªåŠ¨æ‰“ç‚¹æ¨¡å¼

        // æ“ä½œå†å²
        let history = []; // å†å²è®°å½•æ ˆ
        let historyIndex = -1; // å½“å‰å†å²ä½ç½®
        let isApplyingHistory = false; // æ˜¯å¦æ­£åœ¨åº”ç”¨å†å²è®°å½•ï¼ˆé¿å…å¾ªç¯è®°å½•ï¼‰

        // Leaflet å›¾å±‚å­˜å‚¨ï¼Œç”¨äºäº¤äº’
        const markersMap = {}; // uuid -> leaflet marker
        const polylinesMap = {}; // uuid -> leaflet polyline

        // --- åˆå§‹åŒ–åœ°å›¾ ---
        function initMap() {
            // é»˜è®¤å®šä½åˆ°æŒ‡å®šåæ ‡
            map = L.map('map').setView([36.070165121277796, 120.41910235636723], 13);

            L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', {
                maxZoom: 19,
                attribution: '&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a>'
            }).addTo(map);

            // åœ°å›¾ç‚¹å‡»äº‹ä»¶ï¼ˆç”¨äºæ·»åŠ ç‚¹ï¼‰
            map.on('click', function(e) {
                if (currentMode === 'point') {
                    addNode(e.latlng);
                } else {
                    deselectAll();
                }
            });

            // é”®ç›˜å¿«æ·é”®ç›‘å¬
            document.addEventListener('keydown', function(e) {
                // Ctrl+Z æ’¤é”€
                if (e.ctrlKey && e.key === 'z' && !e.shiftKey) {
                    e.preventDefault();
                    undo();
                }
                // Ctrl+Y æˆ– Ctrl+Shift+Z é‡åš
                else if ((e.ctrlKey && e.key === 'y') || (e.ctrlKey && e.shiftKey && e.key === 'z')) {
                    e.preventDefault();
                    redo();
                }
            });

            // åˆå§‹åŒ–å†å²è®°å½•
            saveHistory('init');
        }

        // --- æ ¸å¿ƒé€»è¾‘ï¼šæ·»åŠ èŠ‚ç‚¹ ---
        function addNode(latlng) {
            const uuid = generateUUID();
            const newNode = {
                uuid: uuid,
                name: "New Point",
                pos: [latlng.lat, latlng.lng]
            };

            data.nodes.push(newNode);
            renderNode(newNode);
            console.log("Added Node:", newNode);

            // ä¿å­˜å†å²
            saveHistory('add_node');
        }

        // --- æ¸²æŸ“èŠ‚ç‚¹ ---
        function renderNode(nodeData) {
            const marker = L.marker(nodeData.pos, {draggable: !dragLocked}).addTo(map);
            marker.nodeUuid = nodeData.uuid; // ç»‘å®š ID åˆ°å¯¹è±¡

            // ç‚¹å‡» Marker äº‹ä»¶
            marker.on('click', (e) => {
                L.DomEvent.stopPropagation(e); // é˜²æ­¢è§¦å‘åœ°å›¾ç‚¹å‡»
                handleNodeClick(nodeData.uuid);
            });

            // æ‹–æ‹½ Marker æ›´æ–°åæ ‡
            marker.on('dragend', (e) => {
                const newPos = e.target.getLatLng();
                const node = data.nodes.find(n => n.uuid === nodeData.uuid);
                if(node) {
                    node.pos = [newPos.lat, newPos.lng];
                    updateConnectedEdges(nodeData.uuid); // æ›´æ–°è¿æ¥çš„çº¿
                    if (editingEntity && editingEntity.uuid === nodeData.uuid) {
                        loadProperties('node', nodeData.uuid); // åˆ·æ–°é¢æ¿åæ ‡æ˜¾ç¤º
                    }
                    // æ‹–åŠ¨ç»“æŸåä¿å­˜å†å²
                    saveHistory('move_node');
                }
            });

            markersMap[nodeData.uuid] = marker;
        }

        // --- æ ¸å¿ƒé€»è¾‘ï¼šèŠ‚ç‚¹ç‚¹å‡»å¤„ç† (è¿çº¿æˆ–ç¼–è¾‘) ---
        function handleNodeClick(uuid) {
            if (currentMode === 'line') {
                // è¿çº¿é€»è¾‘
                if (selectedNodeUuid === null) {
                    // é€‰ä¸­ç¬¬ä¸€ä¸ªç‚¹
                    selectedNodeUuid = uuid;
                    highlightMarker(uuid, true);
                    showToast("è¯·ç‚¹å‡»ç¬¬äºŒä¸ªç‚¹ä»¥è¿æ¥");
                } else if (selectedNodeUuid === uuid) {
                    // å–æ¶ˆé€‰ä¸­
                    highlightMarker(uuid, false);
                    selectedNodeUuid = null;
                } else {
                    // é€‰ä¸­ç¬¬äºŒä¸ªç‚¹ -> åˆ›å»ºè¿çº¿
                    addEdge(selectedNodeUuid, uuid);
                    highlightMarker(selectedNodeUuid, false);
                    selectedNodeUuid = null;
                }
            } else {
                // ç¼–è¾‘æ¨¡å¼
                deselectAll();
                loadProperties('node', uuid);
            }
        }

        // --- æ ¸å¿ƒé€»è¾‘ï¼šæ·»åŠ è¿çº¿ ---
        function addEdge(startUuid, endUuid) {
            // æ£€æŸ¥æ˜¯å¦é‡å¤
            const exists = data.edges.some(e =>
                (e.start === startUuid && e.end === endUuid) ||
                (e.start === endUuid && e.end === startUuid)
            );
            if (exists) {
                alert("è¿™ä¸¤ç‚¹ä¹‹é—´å·²ç»å­˜åœ¨è¿çº¿ï¼");
                return;
            }

            const startNode = data.nodes.find(n => n.uuid === startUuid);
            const endNode = data.nodes.find(n => n.uuid === endUuid);

            // è®¡ç®—è·ç¦» (ç±³)
            const dist = map.distance(startNode.pos, endNode.pos);

            const uuid = generateUUID();
            const newEdge = {
                uuid: uuid,
                start: startUuid,
                end: endUuid,
                distance: parseFloat(dist.toFixed(2)),
                walk_punish: 0,
                bike_punish: 0,
                car_punish: 0
            };

            data.edges.push(newEdge);
            renderEdge(newEdge);
            console.log("Added Edge:", newEdge);

            // ä¿å­˜å†å²
            saveHistory('add_edge');
        }

        // --- æ¸²æŸ“è¿çº¿ ---
        function renderEdge(edgeData) {
            const startNode = data.nodes.find(n => n.uuid === edgeData.start);
            const endNode = data.nodes.find(n => n.uuid === edgeData.end);

            if(!startNode || !endNode) return;

            const latlngs = [startNode.pos, endNode.pos];
            const polyline = L.polyline(latlngs, {color: 'blue', weight: 5, opacity: 0.6}).addTo(map);
            polyline.edgeUuid = edgeData.uuid;

            // çº¿æ®µç‚¹å‡»äº‹ä»¶
            polyline.on('click', (e) => {
                L.DomEvent.stopPropagation(e);
                if (currentMode === 'view') {
                    deselectAll();
                    // é«˜äº®çº¿æ®µ
                    polyline.setStyle({color: 'red'});
                    loadProperties('edge', edgeData.uuid);
                }
            });

            polylinesMap[edgeData.uuid] = polyline;
        }

        // --- æ‹–æ‹½ç‚¹æ—¶æ›´æ–°è¿çº¿è§†è§‰ ---
        function updateConnectedEdges(nodeUuid) {
            data.edges.forEach(edge => {
                if (edge.start === nodeUuid || edge.end === nodeUuid) {
                    const polyline = polylinesMap[edge.uuid];
                    const n1 = data.nodes.find(n => n.uuid === edge.start);
                    const n2 = data.nodes.find(n => n.uuid === edge.end);
                    if (polyline && n1 && n2) {
                        polyline.setLatLngs([n1.pos, n2.pos]);
                        // è‡ªåŠ¨æ›´æ–°è·ç¦»
                        edge.distance = parseFloat(map.distance(n1.pos, n2.pos).toFixed(2));
                        // å¦‚æœå½“å‰æ­£åœ¨ç¼–è¾‘è¿™æ¡çº¿ï¼Œåˆ·æ–°è·ç¦»æ˜¾ç¤º
                        if (editingEntity && editingEntity.uuid === edge.uuid) {
                            document.getElementById('inp-distance').value = edge.distance;
                        }
                    }
                }
            });
        }

        // --- å±æ€§é¢æ¿é€»è¾‘ ---
        function loadProperties(type, uuid) {
            const panel = document.getElementById('properties-panel');
            const form = document.getElementById('prop-form');
            const title = document.getElementById('prop-title');
            
            panel.style.display = 'block';
            form.innerHTML = '';
            editingEntity = { type, uuid };

            if (type === 'node') {
                const node = data.nodes.find(n => n.uuid === uuid);
                title.innerText = "ç¼–è¾‘ç‚¹å±æ€§";
                form.innerHTML += createInput('UUID', 'inp-uuid', node.uuid, true);
                form.innerHTML += createInput('åç§° (Name)', 'inp-name', node.name);
                form.innerHTML += createInput('åæ ‡ (Pos)', 'inp-pos', node.pos.join(', '), true);
            } else {
                const edge = data.edges.find(e => e.uuid === uuid);
                title.innerText = "ç¼–è¾‘çº¿å±æ€§";
                form.innerHTML += createInput('UUID', 'inp-uuid', edge.uuid, true);
                form.innerHTML += createInput('è·ç¦» (Distance)', 'inp-distance', edge.distance);
                form.innerHTML += createInput('Walk Punish', 'inp-walk', edge.walk_punish, false, 'number');
                form.innerHTML += createInput('Bike Punish', 'inp-bike', edge.bike_punish, false, 'number');
                form.innerHTML += createInput('Car Punish', 'inp-car', edge.car_punish, false, 'number');
            }
        }

        function createInput(label, id, value, readonly = false, type = 'text') {
            return `
                <div class="form-group">
                    <label>${label}</label>
                    <input type="${type}" id="${id}" value="${value}" ${readonly ? 'readonly class="readonly-input"' : ''}>
                </div>
            `;
        }

        function saveProperties() {
            if (!editingEntity) return;

            if (editingEntity.type === 'node') {
                const node = data.nodes.find(n => n.uuid === editingEntity.uuid);
                node.name = document.getElementById('inp-name').value;
                // æ›´æ–° Marker Popup æˆ– Tooltip (å¯é€‰)
                markersMap[node.uuid].bindPopup(node.name).openPopup();
            } else {
                const edge = data.edges.find(e => e.uuid === editingEntity.uuid);
                edge.distance = parseFloat(document.getElementById('inp-distance').value);
                edge.walk_punish = parseFloat(document.getElementById('inp-walk').value);
                edge.bike_punish = parseFloat(document.getElementById('inp-bike').value);
                edge.car_punish = parseFloat(document.getElementById('inp-car').value);
            }
            showToast("å±æ€§å·²ä¿å­˜");

            // ä¿å­˜å†å²
            saveHistory('edit_properties');
        }

        function deleteCurrentEntity() {
            if (!editingEntity) return;
            if (!confirm("ç¡®å®šè¦åˆ é™¤å—ï¼Ÿ")) return;

            if (editingEntity.type === 'node') {
                // åˆ é™¤ç‚¹åŠç›¸å…³è¿çº¿
                const uuid = editingEntity.uuid;

                // 1. åˆ é™¤ç›¸å…³è¿çº¿æ•°æ®å’Œè§†å›¾
                const relatedEdges = data.edges.filter(e => e.start === uuid || e.end === uuid);
                relatedEdges.forEach(e => {
                    map.removeLayer(polylinesMap[e.uuid]);
                    delete polylinesMap[e.uuid];
                });
                data.edges = data.edges.filter(e => e.start !== uuid && e.end !== uuid);

                // 2. åˆ é™¤ç‚¹è§†å›¾
                map.removeLayer(markersMap[uuid]);
                delete markersMap[uuid];

                // 3. åˆ é™¤ç‚¹æ•°æ®
                data.nodes = data.nodes.filter(n => n.uuid !== uuid);

            } else {
                // ä»…åˆ é™¤è¿çº¿
                const uuid = editingEntity.uuid;
                map.removeLayer(polylinesMap[uuid]);
                delete polylinesMap[uuid];
                data.edges = data.edges.filter(e => e.uuid !== uuid);
            }

            deselectAll();
            document.getElementById('properties-panel').style.display = 'none';

            // ä¿å­˜å†å²
            saveHistory('delete');
        }

        // --- è¾…åŠ©åŠŸèƒ½ ---
        function setMode(mode) {
            currentMode = mode;
            document.querySelectorAll('.mode-btn').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active'); // ç®€å•çš„äº‹ä»¶ç›®æ ‡å¤„ç†ï¼Œå®é™…é¡¹ç›®ä¸­æœ€å¥½ç”¨ID
            
            // é‡ç½®çŠ¶æ€
            selectedNodeUuid = null;
            deselectAll();

            const instruction = document.getElementById('instruction');
            if(mode === 'view') instruction.innerText = "ç‚¹å‡»åœ°å›¾ä¸Šçš„ç‚¹æˆ–çº¿è¿›è¡Œç¼–è¾‘/æ‹–æ‹½ã€‚";
            if(mode === 'point') instruction.innerText = "ç‚¹å‡»åœ°å›¾ä»»æ„ç©ºç™½å¤„æ·»åŠ æ–°çš„ç‚¹ã€‚";
            if(mode === 'line') instruction.innerText = "ä¾æ¬¡ç‚¹å‡»ä¸¤ä¸ªç‚¹ä»¥å»ºç«‹è¿æ¥ã€‚";
        }

        function deselectAll() {
            document.getElementById('properties-panel').style.display = 'none';
            editingEntity = null;
            // é‡ç½®æ‰€æœ‰çº¿çš„é¢œè‰²
            Object.values(polylinesMap).forEach(poly => poly.setStyle({color: 'blue'}));
            // é‡ç½®æ‰€æœ‰ç‚¹çš„é¢œè‰² (è¿™é‡Œä¸»è¦æŒ‡å–æ¶ˆé«˜äº®)
            Object.keys(markersMap).forEach(k => highlightMarker(k, false));
        }

        function highlightMarker(uuid, active) {
            const marker = markersMap[uuid];
            if (!marker) return;
            const icon = marker.getElement();
            if (icon) {
                if (active) icon.classList.add('selected-marker-icon');
                else icon.classList.remove('selected-marker-icon');
            }
        }

        function generateUUID() {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
        }

        function exportJSON() {
            const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(data, null, 2));
            const downloadAnchorNode = document.createElement('a');
            downloadAnchorNode.setAttribute("href", dataStr);
            downloadAnchorNode.setAttribute("download", "map_data.json");
            document.body.appendChild(downloadAnchorNode);
            downloadAnchorNode.click();
            downloadAnchorNode.remove();
        }

        function importJSON() {
            // è§¦å‘éšè—çš„æ–‡ä»¶é€‰æ‹©æ¡†
            document.getElementById('json-file-input').click();
        }

        function handleFileSelect(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const importedData = JSON.parse(e.target.result);

                    // éªŒè¯æ•°æ®æ ¼å¼
                    if (!importedData.nodes || !importedData.edges) {
                        alert("JSON æ ¼å¼ä¸æ­£ç¡®ï¼éœ€è¦åŒ…å« nodes å’Œ edges å­—æ®µã€‚");
                        return;
                    }

                    // æ¸…é™¤å½“å‰æ‰€æœ‰åœ°å›¾å…ƒç´ 
                    clearAllMapData();

                    // å¯¼å…¥èŠ‚ç‚¹æ•°æ®
                    data.nodes = importedData.nodes;
                    data.edges = importedData.edges;

                    // å…ˆæ¸²æŸ“æ‰€æœ‰èŠ‚ç‚¹
                    data.nodes.forEach(node => {
                        renderNode(node);
                    });

                    // å†æ¸²æŸ“æ‰€æœ‰è¿çº¿
                    data.edges.forEach(edge => {
                        renderEdge(edge);
                    });

                    showToast("å¯¼å…¥æˆåŠŸï¼");

                    // è‡ªåŠ¨ç¼©æ”¾åˆ°æ‰€æœ‰ç‚¹
                    if (data.nodes.length > 0) {
                        const bounds = L.latLngBounds(data.nodes.map(n => n.pos));
                        map.fitBounds(bounds, { padding: [50, 50] });
                    }

                    // ä¿å­˜å†å²
                    saveHistory('import');

                } catch (error) {
                    alert("å¯¼å…¥å¤±è´¥ï¼š" + error.message);
                }
            };
            reader.readAsText(file);

            // é‡ç½®æ–‡ä»¶è¾“å…¥ï¼Œå…è®¸é‡å¤å¯¼å…¥åŒä¸€æ–‡ä»¶
            event.target.value = '';
        }

        function clearAllMapData() {
            // æ¸…é™¤æ‰€æœ‰ marker
            Object.values(markersMap).forEach(marker => {
                map.removeLayer(marker);
            });
            Object.keys(markersMap).forEach(key => delete markersMap[key]);

            // æ¸…é™¤æ‰€æœ‰ polyline
            Object.values(polylinesMap).forEach(polyline => {
                map.removeLayer(polyline);
            });
            Object.keys(polylinesMap).forEach(key => delete polylinesMap[key]);

            // æ¸…é™¤æ•°æ®
            data.nodes = [];
            data.edges = [];

            // éšè—å±æ€§é¢æ¿
            deselectAll();
        }

        function toggleDragLock() {
            dragLocked = !dragLocked;
            const btn = document.getElementById('drag-lock-btn');

            if (dragLocked) {
                btn.innerText = 'ğŸ”’ å·²é”å®šæ‹–åŠ¨';
                btn.classList.remove('btn-primary');
                btn.classList.add('btn-danger');
            } else {
                btn.innerText = 'ğŸ”“ å…è®¸æ‹–åŠ¨';
                btn.classList.remove('btn-danger');
                btn.classList.add('btn-primary');
            }

            // æ›´æ–°æ‰€æœ‰ç°æœ‰ marker çš„æ‹–åŠ¨çŠ¶æ€
            Object.values(markersMap).forEach(marker => {
                if (dragLocked) {
                    marker.dragging.disable();
                } else {
                    marker.dragging.enable();
                }
            });

            showToast(dragLocked ? "å·²é”å®šæ‰€æœ‰ç‚¹çš„æ‹–åŠ¨" : "å·²è§£é”æ‰€æœ‰ç‚¹çš„æ‹–åŠ¨");
        }

        function showToast(msg) {
            // ç®€å•çš„æç¤ºï¼Œå®é™…å¯ä»¥ç”¨æ›´å¥½çœ‹çš„UI
            const d = document.createElement('div');
            d.style.cssText = "position:fixed; bottom:20px; right:20px; background:rgba(0,0,0,0.7); color:white; padding:10px 20px; border-radius:5px; z-index:9999;";
            d.innerText = msg;
            document.body.appendChild(d);
            setTimeout(() => d.remove(), 2000);
        }

        // --- è‡ªåŠ¨æ‰“ç‚¹åŠŸèƒ½ ---

        function startAutoMarking() {
            if (isAutoMarkingMode) {
                cancelAutoMarking();
                return;
            }

            isAutoMarkingMode = true;
            updateAutoMarkStatus("è¯·åœ¨åœ°å›¾ä¸Šæ‹–æ‹½æ¡†é€‰åŒºåŸŸ");

            // ç¦ç”¨åœ°å›¾ç‚¹å‡»æ·»åŠ ç‚¹çš„åŠŸèƒ½
            const originalMode = currentMode;
            setMode('view');

            // åˆ›å»ºçŸ©å½¢é€‰æ‹©å·¥å…·
            rectangleSelector = new L.Draw.Rectangle(map, {
                shapeOptions: {
                    color: '#ff7800',
                    weight: 2,
                    opacity: 0.8,
                    fillOpacity: 0.2
                }
            });

            // ç›‘å¬çŸ©å½¢ç»˜åˆ¶å®Œæˆäº‹ä»¶
            map.on(L.Draw.Event.CREATED, handleRectangleCreated);

            rectangleSelector.enable();
        }

        function cancelAutoMarking() {
            isAutoMarkingMode = false;
            updateAutoMarkStatus("");

            if (rectangleSelector) {
                rectangleSelector.disable();
                rectangleSelector = null;
            }

            map.off(L.Draw.Event.CREATED, handleRectangleCreated);
        }

        async function handleRectangleCreated(e) {
            const layer = e.layer;
            const bounds = layer.getBounds();

            // åœæ­¢ç»˜åˆ¶æ¨¡å¼
            cancelAutoMarking();

            // è®¡ç®—é€‰åŒºé¢ç§¯ï¼ˆå¹³æ–¹å…¬é‡Œï¼‰
            const area = calculateArea(bounds);

            if (area > 10) {
                alert(`é€‰æ‹©åŒºåŸŸé¢ç§¯çº¦ ${area.toFixed(2)} kmÂ²ï¼Œè¶…è¿‡ 10 kmÂ² é™åˆ¶ï¼\n\nä¸ºç¡®ä¿æ€§èƒ½å’Œå‡†ç¡®æ€§ï¼Œè¯·åˆ†å¤šæ¬¡æ‰“ç‚¹ã€‚`);
                return;
            }

            updateAutoMarkStatus(`æ­£åœ¨æŸ¥è¯¢è·¯å£æ•°æ®ï¼ˆåŒºåŸŸï¼š${area.toFixed(2)} kmÂ²ï¼‰...`);

            try {
                // ä» OpenStreetMap è·å–è·¯å£æ•°æ®
                const intersections = await fetchIntersections(bounds);

                if (intersections.length === 0) {
                    updateAutoMarkStatus("è¯¥åŒºåŸŸæœªæ‰¾åˆ°è·¯å£");
                    showToast("æœªæ‰¾åˆ°è·¯å£æ•°æ®");
                    return;
                }

                updateAutoMarkStatus(`æ‰¾åˆ° ${intersections.length} ä¸ªè·¯å£ï¼Œæ­£åœ¨å¤„ç†...`);

                // å»é‡å¹¶æ·»åŠ èŠ‚ç‚¹
                const addedNodes = await addIntersectionsWithDedup(intersections);

                updateAutoMarkStatus(`æˆåŠŸæ·»åŠ  ${addedNodes.length} ä¸ªæ–°è·¯å£`);

                // è‡ªåŠ¨è¿çº¿
                if (addedNodes.length > 0) {
                    updateAutoMarkStatus(`æ­£åœ¨è‡ªåŠ¨è¿çº¿...`);
                    const addedEdges = await autoConnectNodes(addedNodes, bounds);
                    updateAutoMarkStatus(`å®Œæˆï¼æ·»åŠ äº† ${addedNodes.length} ä¸ªè·¯å£å’Œ ${addedEdges.length} æ¡è¿çº¿`);
                    showToast(`è‡ªåŠ¨æ‰“ç‚¹å®Œæˆï¼š${addedNodes.length} ä¸ªè·¯å£ï¼Œ${addedEdges.length} æ¡è¿çº¿`);

                    // ä¿å­˜å†å²
                    saveHistory('auto_marking');
                }

            } catch (error) {
                console.error("è‡ªåŠ¨æ‰“ç‚¹å¤±è´¥:", error);
                updateAutoMarkStatus("è‡ªåŠ¨æ‰“ç‚¹å¤±è´¥ï¼š" + error.message);
                alert("è‡ªåŠ¨æ‰“ç‚¹å¤±è´¥ï¼š" + error.message);
            }
        }

        function calculateArea(bounds) {
            // è®¡ç®—çŸ©å½¢åŒºåŸŸé¢ç§¯ï¼ˆå¹³æ–¹å…¬é‡Œï¼‰
            const ne = bounds.getNorthEast();
            const sw = bounds.getSouthWest();
            const nw = L.latLng(ne.lat, sw.lng);
            const se = L.latLng(sw.lat, ne.lng);

            const width = map.distance(nw, ne); // ç±³
            const height = map.distance(nw, sw); // ç±³

            return (width * height) / 1000000; // è½¬æ¢ä¸ºå¹³æ–¹å…¬é‡Œ
        }

        async function fetchIntersections(bounds) {
            const south = bounds.getSouth();
            const west = bounds.getWest();
            const north = bounds.getNorth();
            const east = bounds.getEast();

            updateAutoMarkStatus(`æ­£åœ¨è·å–é“è·¯æ•°æ®...`);

            // ä½¿ç”¨ Overpass API è·å–é“è·¯æ•°æ®
            const query = `
                [out:json][timeout:30];
                (
                  way["highway"]["highway"!="footway"]["highway"!="path"]["highway"!="cycleway"]["highway"!="steps"](${south},${west},${north},${east});
                );
                out body;
                >;
                out skel qt;
            `;

            const url = 'https://overpass-api.de/api/interpreter';

            try {
                const response = await fetch(url, {
                    method: 'POST',
                    body: query
                });

                if (!response.ok) {
                    throw new Error(`API å“åº”é”™è¯¯: ${response.status}`);
                }

                const data = await response.json();

                updateAutoMarkStatus(`å·²è·å– ${data.elements.filter(e => e.type === 'way').length} æ¡é“è·¯ï¼Œæ­£åœ¨è®¡ç®—è·¯å£...`);

                // è®¡ç®—è·¯å£
                return calculateIntersectionsFromWays(data.elements, bounds);

            } catch (error) {
                console.error('Overpass API é”™è¯¯:', error);
                throw new Error('æ— æ³•è·å–é“è·¯æ•°æ®ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥');
            }
        }

        function calculateIntersectionsFromWays(elements, bounds) {
            // æ„å»ºèŠ‚ç‚¹æ˜ å°„å’Œé“è·¯æ˜ å°„
            const nodeMap = new Map(); // nodeId -> {lat, lon, wayIds: []}
            const ways = [];

            // ç¬¬ä¸€éï¼šæ”¶é›†æ‰€æœ‰èŠ‚ç‚¹
            elements.forEach(element => {
                if (element.type === 'node') {
                    nodeMap.set(element.id, {
                        id: element.id,
                        lat: element.lat,
                        lon: element.lon,
                        wayIds: [],
                        tags: element.tags || {}
                    });
                }
            });

            // ç¬¬äºŒéï¼šæ”¶é›†é“è·¯å¹¶å…³è”èŠ‚ç‚¹
            elements.forEach(element => {
                if (element.type === 'way' && element.nodes && element.nodes.length >= 2) {
                    ways.push({
                        id: element.id,
                        nodes: element.nodes,
                        tags: element.tags || {}
                    });

                    // è®°å½•æ¯ä¸ªèŠ‚ç‚¹å±äºå“ªäº›é“è·¯
                    element.nodes.forEach(nodeId => {
                        const node = nodeMap.get(nodeId);
                        if (node) {
                            node.wayIds.push(element.id);
                        }
                    });
                }
            });

            // æ‰¾å‡ºè·¯å£ï¼šè¢«2æ¡æˆ–æ›´å¤šé“è·¯å…±äº«çš„èŠ‚ç‚¹
            const intersections = [];
            const south = bounds.getSouth();
            const west = bounds.getWest();
            const north = bounds.getNorth();
            const east = bounds.getEast();

            nodeMap.forEach((node, nodeId) => {
                // è·¯å£æ¡ä»¶ï¼š
                // 1. è‡³å°‘è¢«2æ¡ä¸åŒé“è·¯ä½¿ç”¨
                // 2. åœ¨è¾¹ç•ŒèŒƒå›´å†…
                if (node.wayIds.length >= 2 &&
                    node.lat >= south && node.lat <= north &&
                    node.lon >= west && node.lon <= east) {

                    // æ£€æŸ¥æ˜¯å¦æ˜¯é“è·¯çš„ç«¯ç‚¹ï¼ˆèµ·ç‚¹æˆ–ç»ˆç‚¹ï¼‰
                    let isEndpoint = false;
                    for (let wayId of node.wayIds) {
                        const way = ways.find(w => w.id === wayId);
                        if (way && (way.nodes[0] === nodeId || way.nodes[way.nodes.length - 1] === nodeId)) {
                            isEndpoint = true;
                            break;
                        }
                    }

                    // æ·»åŠ è·¯å£
                    intersections.push({
                        osmId: nodeId,
                        lat: node.lat,
                        lon: node.lon,
                        tags: node.tags,
                        wayCount: node.wayIds.length,
                        isEndpoint: isEndpoint
                    });
                }
            });

            // æŒ‰é“è·¯æ•°é‡æ’åºï¼ˆæ›´å¤šé“è·¯äº¤æ±‡çš„è·¯å£ä¼˜å…ˆï¼‰
            intersections.sort((a, b) => b.wayCount - a.wayCount);

            return intersections;
        }

        function addIntersectionsWithDedup(intersections) {
            return new Promise((resolve) => {
                const addedNodes = [];
                const DEDUP_THRESHOLD = 10; // 10ç±³å†…è§†ä¸ºé‡å¤

                intersections.forEach(intersection => {
                    const pos = [intersection.lat, intersection.lon];

                    // æ£€æŸ¥æ˜¯å¦ä¸å·²æœ‰ç‚¹é‡å¤
                    const isDuplicate = data.nodes.some(existingNode => {
                        const distance = map.distance(existingNode.pos, pos);
                        return distance < DEDUP_THRESHOLD;
                    });

                    if (!isDuplicate) {
                        // ç”ŸæˆèŠ‚ç‚¹åç§°
                        let name = "è·¯å£";

                        if (intersection.tags.name) {
                            name = intersection.tags.name;
                        } else if (intersection.tags.highway === "traffic_signals") {
                            name = "çº¢ç»¿ç¯";
                        } else if (intersection.tags.highway === "crossing") {
                            name = "äººè¡Œæ¨ªé“";
                        } else if (intersection.wayCount >= 4) {
                            name = `è·¯å£ (${intersection.wayCount}æ¡è·¯)`;
                        } else if (intersection.wayCount === 3) {
                            name = "ä¸‰å²”è·¯å£";
                        } else if (intersection.wayCount === 2) {
                            name = intersection.isEndpoint ? "è·¯æ®µè¿æ¥" : "è·¯å£";
                        }

                        const uuid = generateUUID();
                        const newNode = {
                            uuid: uuid,
                            name: name,
                            pos: pos
                        };

                        data.nodes.push(newNode);
                        renderNode(newNode);
                        addedNodes.push(newNode);
                    }
                });

                resolve(addedNodes);
            });
        }

        function autoConnectNodes(nodes, bounds) {
            return new Promise((resolve) => {
                const addedEdges = [];
                const MAX_CONNECTION_DISTANCE = 200; // æœ€å¤§è¿æ¥è·ç¦»200ç±³

                // å¯¹äºæ¯ä¸ªæ–°æ·»åŠ çš„èŠ‚ç‚¹
                nodes.forEach(node => {
                    // æ‰¾åˆ°è¯¥åŒºåŸŸå†…æ‰€æœ‰èŠ‚ç‚¹ï¼ˆåŒ…æ‹¬åŸæœ‰èŠ‚ç‚¹å’Œæ–°èŠ‚ç‚¹ï¼‰
                    const nearbyNodes = data.nodes.filter(n => {
                        if (n.uuid === node.uuid) return false;

                        const distance = map.distance(node.pos, n.pos);
                        return distance <= MAX_CONNECTION_DISTANCE;
                    });

                    // æŒ‰è·ç¦»æ’åº
                    nearbyNodes.sort((a, b) => {
                        const distA = map.distance(node.pos, a.pos);
                        const distB = map.distance(node.pos, b.pos);
                        return distA - distB;
                    });

                    // è¿æ¥åˆ°æœ€è¿‘çš„2-4ä¸ªèŠ‚ç‚¹ï¼ˆæ¨¡æ‹Ÿé“è·¯ç½‘ï¼‰
                    const connectCount = Math.min(4, nearbyNodes.length);
                    for (let i = 0; i < connectCount; i++) {
                        const targetNode = nearbyNodes[i];

                        // æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨è¿çº¿
                        const exists = data.edges.some(e =>
                            (e.start === node.uuid && e.end === targetNode.uuid) ||
                            (e.start === targetNode.uuid && e.end === node.uuid)
                        );

                        if (!exists) {
                            // ä½¿ç”¨ç°æœ‰çš„è·ç¦»è®¡ç®—æ–¹æ³•
                            const dist = map.distance(node.pos, targetNode.pos);
                            const uuid = generateUUID();
                            const newEdge = {
                                uuid: uuid,
                                start: node.uuid,
                                end: targetNode.uuid,
                                distance: parseFloat(dist.toFixed(2)),
                                walk_punish: 0,
                                bike_punish: 0,
                                car_punish: 0
                            };

                            data.edges.push(newEdge);
                            renderEdge(newEdge);
                            addedEdges.push(newEdge);
                        }
                    }
                });

                resolve(addedEdges);
            });
        }

        function updateAutoMarkStatus(message) {
            const statusDiv = document.getElementById('auto-mark-status');
            statusDiv.innerText = message;
        }

        // --- æ“ä½œå†å²ç®¡ç† ---

        function saveHistory(action) {
            // å¦‚æœæ­£åœ¨åº”ç”¨å†å²è®°å½•ï¼Œä¸ä¿å­˜æ–°çš„å†å²
            if (isApplyingHistory) return;

            // æ·±æ‹·è´å½“å‰æ•°æ®çŠ¶æ€
            const snapshot = {
                nodes: JSON.parse(JSON.stringify(data.nodes)),
                edges: JSON.parse(JSON.stringify(data.edges)),
                action: action,
                timestamp: Date.now()
            };

            // å¦‚æœå½“å‰ä¸åœ¨å†å²çš„æœ«å°¾ï¼Œåˆ é™¤åé¢çš„å†å²
            if (historyIndex < history.length - 1) {
                history = history.slice(0, historyIndex + 1);
            }

            // æ·»åŠ æ–°çš„å†å²è®°å½•
            history.push(snapshot);
            historyIndex++;

            // é™åˆ¶å†å²è®°å½•æ•°é‡ï¼ˆæœ€å¤šä¿å­˜50æ¡ï¼‰
            if (history.length > 50) {
                history.shift();
                historyIndex--;
            }

            // æ›´æ–°æŒ‰é’®çŠ¶æ€
            updateHistoryButtons();
        }

        function undo() {
            if (historyIndex <= 0) return;

            historyIndex--;
            applyHistoryState(history[historyIndex]);
            updateHistoryButtons();
        }

        function redo() {
            if (historyIndex >= history.length - 1) return;

            historyIndex++;
            applyHistoryState(history[historyIndex]);
            updateHistoryButtons();
        }

        function applyHistoryState(snapshot) {
            isApplyingHistory = true;

            // æ¸…é™¤æ‰€æœ‰åœ°å›¾å…ƒç´ 
            clearAllMapData();

            // æ¢å¤æ•°æ®
            data.nodes = JSON.parse(JSON.stringify(snapshot.nodes));
            data.edges = JSON.parse(JSON.stringify(snapshot.edges));

            // é‡æ–°æ¸²æŸ“æ‰€æœ‰èŠ‚ç‚¹
            data.nodes.forEach(node => {
                renderNode(node);
            });

            // é‡æ–°æ¸²æŸ“æ‰€æœ‰è¿çº¿
            data.edges.forEach(edge => {
                renderEdge(edge);
            });

            isApplyingHistory = false;
        }

        function updateHistoryButtons() {
            const undoBtn = document.getElementById('undo-btn');
            const redoBtn = document.getElementById('redo-btn');

            // æ›´æ–°æ’¤é”€æŒ‰é’®
            if (historyIndex > 0) {
                undoBtn.disabled = false;
                undoBtn.classList.remove('btn-secondary');
                undoBtn.classList.add('btn-primary');
            } else {
                undoBtn.disabled = true;
                undoBtn.classList.remove('btn-primary');
                undoBtn.classList.add('btn-secondary');
            }

            // æ›´æ–°é‡åšæŒ‰é’®
            if (historyIndex < history.length - 1) {
                redoBtn.disabled = false;
                redoBtn.classList.remove('btn-secondary');
                redoBtn.classList.add('btn-primary');
            } else {
                redoBtn.disabled = true;
                redoBtn.classList.remove('btn-primary');
                redoBtn.classList.add('btn-secondary');
            }
        }

        // å¯åŠ¨
        initMap();

    </script>
</body>
</html>